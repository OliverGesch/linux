<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Xenomai: Thread management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search-opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0-rc3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__api__thread.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread management<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__api.html">POSIX interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Cobalt/POSIX thread management services.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Thread management:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__api__thread.png" border="0" alt="" usemap="#group____cobalt____api____thread"/>
<map name="group____cobalt____api____thread" id="group____cobalt____api____thread">
<area shape="rect" id="node1" href="group__cobalt__api.html" title="The Cobalt/POSIX interface is an implementation of a subset of the Single Unix specification over the..." alt="" coords="5,5,123,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae1a96424296ef872696c7fb90a8ae9aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__api__thread.html#gae1a96424296ef872696c7fb90a8ae9aa">pthread_create</a> (pthread_t *ptid_r, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>
<tr class="memdesc:gae1a96424296ef872696c7fb90a8ae9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new thread.  <a href="#gae1a96424296ef872696c7fb90a8ae9aa">More...</a><br /></td></tr>
<tr class="separator:gae1a96424296ef872696c7fb90a8ae9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b7df7f77c04253ed19fb6346f0f9b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__api__thread.html#gae3b7df7f77c04253ed19fb6346f0f9b2">pthread_setmode_np</a> (int clrmask, int setmask, int *mode_r)</td></tr>
<tr class="memdesc:gae3b7df7f77c04253ed19fb6346f0f9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#gae3b7df7f77c04253ed19fb6346f0f9b2">More...</a><br /></td></tr>
<tr class="separator:gae3b7df7f77c04253ed19fb6346f0f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa21465e084e7185bfbb94bb50d60cd08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__api__thread.html#gaa21465e084e7185bfbb94bb50d60cd08">pthread_setname_np</a> (pthread_t thread, const char *name)</td></tr>
<tr class="memdesc:gaa21465e084e7185bfbb94bb50d60cd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a thread name.  <a href="#gaa21465e084e7185bfbb94bb50d60cd08">More...</a><br /></td></tr>
<tr class="separator:gaa21465e084e7185bfbb94bb50d60cd08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aafacc071cdfafd0eb992004dee3e62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__api__thread.html#ga5aafacc071cdfafd0eb992004dee3e62">pthread_kill</a> (pthread_t thread, int sig)</td></tr>
<tr class="memdesc:ga5aafacc071cdfafd0eb992004dee3e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a thread.  <a href="#ga5aafacc071cdfafd0eb992004dee3e62">More...</a><br /></td></tr>
<tr class="separator:ga5aafacc071cdfafd0eb992004dee3e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28a15bba47cab57cbc9f5dac9af99c8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__api__thread.html#ga28a15bba47cab57cbc9f5dac9af99c8b">pthread_join</a> (pthread_t thread, void **retval)</td></tr>
<tr class="memdesc:ga28a15bba47cab57cbc9f5dac9af99c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for termination of a specified thread.  <a href="#ga28a15bba47cab57cbc9f5dac9af99c8b">More...</a><br /></td></tr>
<tr class="separator:ga28a15bba47cab57cbc9f5dac9af99c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cobalt/POSIX thread management services. </p>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae1a96424296ef872696c7fb90a8ae9aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&#160;</td>
          <td class="paramname"><em>ptid_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new thread. </p>
<p>This service creates a thread managed by the Xenomai nucleus in dual kernel configuration.</p>
<p>The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__cobalt__api__thread.html#gae1a96424296ef872696c7fb90a8ae9aa" title="Create a new thread. ">pthread_create()</a>, otherwise the new thread signal mask is empty.</p>
<p>Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is NULL, default values for these attributes are used.</p>
<p>Returning from the <em>start</em> routine has the same effect as calling pthread_exit() with the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptid_r</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td class="paramname">attr</td><td>thread attributes;</td></tr>
    <tr><td class="paramname">start</td><td>thread start routine;</td></tr>
    <tr><td class="paramname">arg</td><td>opaque user-supplied argument passed to <em>start</em>;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li>
<li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the Cobalt interface;</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGSHADOW signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGSHADOW signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGSHADOW after creating or shadowing the first Xenomai thread, you have to explicitly call the function cobalt_sigshadow_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). cobalt_sigshadow_handler prototype is:</p>
<p><b>int cobalt_sigshadow_handler(int sig, struct siginfo *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to cobalt_sigshadow_handler. </p>

</div>
</div>
<a class="anchor" id="ga28a15bba47cab57cbc9f5dac9af99c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_join </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for termination of a specified thread. </p>
<p>If the thread <em>thread</em> is running and joinable, this service blocks the calling thread until the thread <em>thread</em> terminates or detaches. In this case, the calling context must be a blockable context (i.e. a Xenomai thread without the scheduler locked) or the root thread (i.e. a module initilization or cleanup routine). When <em>thread</em> terminates, the calling thread is unblocked and its return value is stored at* the address <em>value_ptr</em>.</p>
<p>If, on the other hand, the thread <em>thread</em> has already finished execution, its return value is stored at the address <em>value_ptr</em> and this service returns immediately. In this case, this service may be called from any context.</p>
<p>This service is a cancelation point for POSIX skin threads: if the calling thread is canceled while blocked in a call to this service, the cancelation request is honored and <em>thread</em> remains joinable.</p>
<p>Multiple simultaneous calls to <a class="el" href="group__cobalt__api__thread.html#ga28a15bba47cab57cbc9f5dac9af99c8b" title="Wait for termination of a specified thread. ">pthread_join()</a> specifying the same running target thread block all the callers until the target thread terminates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>identifier of the thread to wait for;</td></tr>
    <tr><td class="paramname">retval</td><td>address where the target thread return value will be stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>EDEADLK, attempting to join the calling thread;</li>
<li>EINVAL, <em>thread</em> is detached;</li>
<li>EPERM, the caller context is invalid.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_join.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__task.html#ga8c77d57638578a126812e29429f61fe7">rt_task_join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5aafacc071cdfafd0eb992004dee3e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_kill </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to a thread. </p>
<p>This service send the signal <em>sig</em> to the Xenomai POSIX skin thread <em>thread</em> (created with <a class="el" href="group__cobalt__api__thread.html#gae1a96424296ef872696c7fb90a8ae9aa" title="Create a new thread. ">pthread_create()</a>). If <em>sig</em> is zero, this service check for existence of the thread <em>thread</em>, but no signal is sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>thread identifier;</td></tr>
    <tr><td class="paramname">sig</td><td>signal number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, <em>sig</em> is an invalid signal number;</li>
<li>EAGAIN, the maximum number of pending signals has been exceeded;</li>
<li>ESRCH, <em>thread</em> is an invalid thread identifier.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_kill.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae3b7df7f77c04253ed19fb6346f0f9b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_setmode_np </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mode_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the mode of the current thread. </p>
<p>This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:</p><ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out until the scheduler is unlocked;</li>
<li>PTHREAD_WARNSW, when set, causes the signal SIGDEBUG to be sent to the current thread, whenever it involontary switches to secondary mode;</li>
<li>PTHREAD_CONFORMING can be passed in <em>setmask</em> to switch the current user-space task to its preferred runtime mode. The only meaningful use of this switch is to force a real-time shadow back to primary mode. Any other use leads to a nop.</li>
<li>PTHREAD_DISABLE_LOCKBREAK disallows breaking the scheduler lock. In the default case, a thread which holds the scheduler lock is allowed to drop it temporarily for sleeping. If this mode bit is set, such thread would return with EINTR immediately from any blocking call.</li>
</ul>
<p>PTHREAD_LOCK_SCHED and PTHREAD_DISABLE_LOCKBREAK are valid for any Xenomai thread, other bits are valid for Xenomai user-space threads only.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clrmask</td><td>set of bits to be cleared;</td></tr>
    <tr><td class="paramname">setmask</td><td>set of bits to be set.</td></tr>
    <tr><td class="paramname">mode_r</td><td>If non-NULL, <em>mode_r</em> must be a pointer to a memory location which will be written upon success with the previous set of active mode bits. If NULL, the previous set of active mode bits will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting <em>clrmask</em> and <em>setmask</em> to zero leads to a nop, only returning the previous mode if <em>mode_r</em> is a valid address. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa21465e084e7185bfbb94bb50d60cd08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_setname_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a thread name. </p>
<p>This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>target thread;</td></tr>
    <tr><td class="paramname">name</td><td>name of the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
